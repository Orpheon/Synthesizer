\documentclass[11pt,a4paper]{article}

% Arial
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

% 1.5 distance between lines
\linespread{1.5}

% reduce those generous margins a bit
\usepackage[hmargin=3.5cm,vmargin=3cm]{geometry}

% keep the text clean
\usepackage[fleqn]{nccmath}
\usepackage{enumitem}
\setlist[itemize]{noitemsep}
\setdescription{leftmargin=\parindent,labelindent=1cm}
\usepackage[parfill]{parskip}

% pgfplots for more complex stuff
\usepackage{pgfplots}
\usetikzlibrary{arrows}
\pagestyle{empty}

% Wrapping for figures
\usepackage{wrapfig}

% Java source code support
\usepackage{listings}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\linespread{0.8}\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=4
}

% Define floor
\providecommand{\floor}[1]{\left \lfloor #1 \right \rfloor }

% Math stuff
\usepackage{amsmath}

% Title
\title{\LARGE \textbf {TITLE} \vspace{1em}}
\author{Alexander Liebend\"{o}rfer}

% Document
\begin{document}
\maketitle
\clearpage
\tableofcontents

\clearpage

\section{Preface}

\subsection{Motivation}

\section{Introduction}

\subsection{Description}

\subsubsection{Synthesizers}

\section{Tools}

The only physical tools used were a computer with peripherals, and a sound system. Several software tools were used though, and I will briefly discuss the most important ones here.

The software itself is programmed in \emph{Java} (by Oracle), and hence is dependent of the \emph{Java runtime environment} (JRE) and all it's requirements. As interface between my software and the OS sound system I used the standard \emph{Java Sound API}, which is part of the javax module package. The GUI itself was made through a popular GUI library called \emph{Swing}, which is also used in many professional applications.

On top of the tools directly implicated in the making of the software, a few additional ones were used to facâ€Žilitate it. A rather famous IDE named \emph{Eclipse} was used for all Java programming, and of enormous importance was the version control system \emph{Git} (with a few extra features from the webservice \emph{Github}). \emph{Python} and \emph{Veusz} were slightly used for debugging and graphing purposes, especially for displaying sound output as an image, but have no direct part in the software.

Finally, this text was created with \emph{LaTeX} and the \emph{TikZ} graphing package for all graphs. Certain parts were created with help of the geometry package \emph{Geogebra}, but were always modified afterwards.

\clearpage

\section{Implementation}

\subsection{Pipes and Modules}

To achieve a completely modular synthesizer, we already need to give up a fixed circuit and have to use the module concept. On top of that, because of recursive loops, we need to actually let the data flow between the different modules, and not just sum the effects of the modules recursively. This means we need at least 1 buffer between every module. We also need a clear way to connect those modules, so a pipe system for connecting inputs and outputs of different modules will be necessary. And finally, some way to inject the current MIDI data and duration of every note as well as a way to capture the processed sound for output is needed.

\subsubsection{Basic system}

In this specific implementation, modules are pure functions, or atleast behave as such towards the outside. A module is always connected to other modules via so-called pipes, which contain the actual data. Modules can then load the data from their input pipes, process it, and dump the result into their output pipes. The main advantage of this system is that it's stable and will work with any wiring setup, even feedback loops. In such closed feedback systems, there will be a propagation delay depending on the amount of pipes the data has to travel, and so no infinite recursion appears. Splitting data and doing parallel processing before merging it again is also implicitely supported, as every module and pipe only acts locally.
One major issue is execution order. A recursive "pull" query where every module calls the modules it depends on for their output cannot work, infinite recursion is a possibility. Even without recursion, there is always the risk that some part of the circuit did not get updated, which might affect the rest. I haven't found a clean solution to this without drawbacks, the one I chose just makes every module execute once in more or less random order (it is not truely random, in fact it is in order of creation), which in worse case makes a signal wait an extra frame between two modules but guarantees that every module is executed once and only once per frame, and done so in a consistent way.

Injection of user input and retrieval of the sound output is best done with modules dedicated to that. These modules possess only 1 input or output port respectively, and do not by themselves do anything. They just serve as convienient place to connect pipes to, and the main overarching engine can simply read and write the contents of their pipes.

\subsubsection{Dealing with Time}

A tricky problem is dealing with time-sensitive modules, like envelopes or oscillators. The input does not implicitely declare it's source, so there needs to be a way for the pipes to also carry starting time of a signal. For this, I implemented a separate counter in every pipe, which showed the time at which that signal started. When a module is done with processing and copies the signal data into its output, it also copies in the counter. A negative time can be used as a marker that the pipe is inactive and that module doesn't even need to process anything. Every module can define a special pipe which is taken as reference for the source time, which is especially important when conflicts are possible. If a module does not define such a pipe, the highest starting time (the most recent signal) of all input pipes is assumed to be the reference.

\subsubsection{Stereo/Mono and Polyphony support}

Making one sound is nice, but for making anything remotely musical one must be able to play several sounds at once. Infinite simultaneous sounds would be ideal, but is technically impossible. A number of different channels though, usually around 8 or 16, is simple to implement. Every sound buffer in the pipe is transformed into an array of buffers, and the starting time is transformed into an array. Modules then just iterate between all channels and behave normally for each pipe.
Additionally, a nice feature would be stereo support. My implementation lacks stereo support in the java api calls and the gui, but the engine itself and all the modules and pipes can use stereo. For that, all buffers across all channels are duplicated, to be calculated separately. In fact, there is little difference between stereo and a second layer of channels for polyphony, and so it is treated much the same way.

\subsection{Oscillators}

Oscillators are generators that can create a periodic waveform. They are the basis of additive and subtractive synthesis by creating a basic wave to be shaped and modified by every other module. Usually osillators create a few types of mathematically well-defined primitive waveforms, like sine or square waves. Apart from the wave function, they also possess two parameters, frequency and phase. Frequency describes the amount of oscillations per second, and a difference in frequency is percieved as a difference in pitch. Phase is very difficult to percieve audibly in most cases, it is the initial offset the oscillation started with. Contrarily to frequency, phase has a bounded range, usually from 0 to 2$\pi$ or from 0 to 1, depending on the implementation.

In this synthesizer, the 3 most fundamental waveforms are supported. These are the sine wave, the "square wave" or pulse wave, and the popular sawtooth-wave, also called saw-wave.
\begin{figure}[h]
\caption{Common basic waveforms}
\centering
\resizebox{\textwidth}{!}{
    % Sine wave
    \begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=1.0cm,y=1.0cm]
    \draw[->,color=black] (-1,0) -- (18,0);
    \foreach \x in {-1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}
    \draw[shift={(\x,0)},color=black] (0pt,-2pt);
    \draw[->,color=black] (0,-2) -- (0,2);
    \foreach \y in {-2,-1,1}
    \draw[shift={(0,\y)},color=black] (2pt,0pt) -- (-2pt,0pt);
    \clip(-1,-2) rectangle (18,2);
    \draw[smooth,color=blue,samples=100,domain=-1.0:18.0] plot(\x,{sin(((\x))*180/pi)});
    \node [above] at (2,1) {\large Sine wave};
    \end{tikzpicture}
}
\resizebox{\textwidth}{!}{
    % Square wave
    \begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=1.0cm,y=1.0cm]
    \draw[->,color=black] (-1,0) -- (18,0);
    \foreach \x in {-1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18}
    \draw[shift={(\x,0)},color=black] (0pt,-2pt);
    \draw[->,color=black] (0,-2) -- (0,2);
    \foreach \y in {-2,-1,1,2}
    \draw[shift={(0,\y)},color=black] (2pt,0pt) -- (-2pt,0pt);
    \clip(-1,-2) rectangle (18,2);
    \foreach \k in {-1,1,...,17} {
        \def\u{\k*3.141592653589793 - 0.5};
        \draw [color=blue] (\u,-1) -- (\u+3.141592653589793,-1);
        \draw [color=blue] (\u,1) -- (\u,-1);
    }
    \foreach \k in {0,2,...,18} {
        \def\u{\k*3.141592653589793 - 0.5};
        \draw [color=blue] (\u,1) -- (\u+3.141592653589793,1);
        \draw [color=blue] (\u,1) -- (\u,-1);
    }
    \node [above] at (2,1) {\large Square wave};
    \end{tikzpicture}
}
\resizebox{\textwidth}{!}{
    % Saw wave
    \begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=1.0cm,y=1.0cm]
    \draw[->,color=black] (-1,0) -- (18,0);
    \foreach \x in {-1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18}
    \draw[shift={(\x,0)},color=black] (0pt,-2pt);
    \draw[->,color=black] (0,-2) -- (0,2);
    \foreach \y in {-2,-1,1,2}
    \draw[shift={(0,\y)},color=black] (2pt,0pt) -- (-2pt,0pt);
    \clip(-1,-2) rectangle (18,2);
    \foreach \k in {-1,...,18} {
        \def\u{\k*3.141592653589793 - 0.5};
        \draw [color=blue] (\u,-1) -- (\u+3.141592653589793,1);
        \draw [color=blue] (\u,1) -- (\u,-1);
    }
    \node [above] at (2,1) {\large Saw wave};
    \end{tikzpicture}
}
\end{figure}

\subsubsection{Basic implementation}

As already noted, oscillators only require two parameters, phase and frequency. It is quite easy to deal with stereo behavior, as the channels are independent, one can simply first calculate the left side and then the right side. Oscillators also depend heavily on the global time and on the pipe starting time. Through this the current time since starting to oscillate can be calculated trivially, and it is generally a good idea to do modulo the period of the wave as well. Afterwards, the resulting signal is calculated differently depending on the type.
\\\begin{minipage}{\linewidth}
\begin{lstlisting}
double x = time * frequency + phase;
switch (osc_type)
{
	case SINE_WAVE:
		return Math.sin(x*2*Math.PI);

	case SQUARE_WAVE:
		if (x <= 0.5)
		{
		    return 1;
		}
		else
		{
		    return -1;
		}

	case SAW_WAVE:
		return 2*(x - Math.floor(x)) - 1;
}
\end{lstlisting}
\end{minipage}

\subsubsection{Anti-Aliased implementation}

The previous approach worked fine for sine waves, but in both other waveforms there is a regular discontinuity. In the frequency range, this translates to an infinite frequency, inducing aliasing, as the Nyquist frequency cannot be infinite.
There are many, many approaches to fixing this problem in general, it is a recurring obstacle in everything from 3D-graphics to font rendering, and it affects synthesis as well. Luckily, the two waveforms we need are special; their frequencies are easily represented as infinite sums. On top of that, we do not need a particularly fast solution, so we can settle for a mathematically simple and complete one.

The saw wave, in the frequency domain, is nothing but the sum of every harmonic (whole-number multiples of the base frequency) with a 1/k decaying amplitude.
(\(f = \) the base frequency, \(F_N = \) the Nyquist frequency)
\begin{equation}
H(f) = \frac{2}{\pi}\sum\limits_{k=1}^\infty{\frac{\sin(k*f)}{k}}
\end{equation}
{\small \it Note: The \(\frac{2}{\pi}\) normalises the result between -1 and 1.}

Of course, instead of summing to infinity, we could stop summing as soon as \(k*f > F_N\), therefore only including overtones under the Nyquist frequency.
\begin{equation}
H(f) = \frac{2}{\pi}\sum\limits_{k=1}^\frac{F_N}{f}{\frac{\sin(k*f)}{k}}
\end{equation}

The same can be done for square waves. Square waves have nearly an identical frequency sum, except only odd harmonics have a non-zero amplitude (this also doubles the normalizing factor, since the range is still -1 to 1 but only half the elements are summed).

\begin{equation}
H(f) = \frac{4}{\pi}\sum\limits_{k=1}^\infty{\frac{\sin((2*k-1)*f)}{2*k-1}}
\end{equation}
becomes
\begin{equation}
H(f) = \frac{4}{\pi}\sum\limits_{k=1}^\frac{F_N}{2f}{\frac{\sin((2*k-1)*f)}{2*k-1}}
\end{equation}
which again, only includes all parts of the square wave which are under the Nyquist frequency; a perfect solution, if we have the luxury of enough computing time to calculate this sum (which, for this synthesizer, we do).

In code, the final result looks like this:
\\\begin{minipage}{\linewidth}
\begin{lstlisting}
double x = time * frequency + phase;
switch (osc_type)
{
	case SINE_WAVE:
		return Math.sin(x*2*Math.PI);
	
	case SAW_WAVE:
		result = 0;
		// Sawtooth = infinite sum of all harmonics with A=1/n for nth harmonic
		// Source: http://en.wikipedia.org/wiki/Sawtooth_wave
		for (int k=1; k*freq<Constants.SAMPLING_RATE/2; k++)
		{
			result += Math.sin(x*2*Math.PI*k)/k;
		}
		// Keep result -1 <= x <= 1, not -1.0903783642160645 because of imprecision
		return Math.min(1, Math.max(-1, 2*result/Math.PI));
		
	case SQUARE_WAVE:
		result = 0;
		// Square = infinite sum of odd harmonics with A=1/n for nth harmonic
		// Source: http://en.wikipedia.org/wiki/Square_wave#Examining_the_square_wave
		for (int k=1; k*freq<Constants.SAMPLING_RATE/2; k+=2)
		{
			result += Math.sin(x*2*Math.PI*k)/k;
		}
		// Keep result -1 <= x <= 1, not -1.0903783642160645 because of imprecision
		return Math.min(1, Math.max(-1, 4*result/Math.PI));
}
\end{lstlisting}
\end{minipage}
This code gives off perfect anti-aliasing and is fast enough for use in our synthesizer.

\subsection{Filters}

Filters are an enormously complex subject and a field for themselves, having a wide range of applications beyond music especially in communications and data analysis. The general definition of a filter is very broad, I am going to refer specifically to filters that modify the gain as a function of frequency.
Even of these, innumerable examples exist, so I will concentrate on the commonly used musical filters. By far the most famous of those are the lowpass and highpass filters.
A lowpass filter, as the name would suggest, lets low frequencies pass while blocking high frequencies. A highpass filter does just the opposite.
There are more types of filters common in synthesizers, most notably bandpass and bandreject (also called notch) filters, but I have not implemented them, so I won't do more than mention them here.

All of the following filters have at least one very important parameter, the cutoff frequency. Informally stated, this is the location of the filter. Raising the cutoff frequency of a lowpass filter for example allows more frequencies to pass through.
\begin{figure}
\centering
\caption{Ideal filter frequency responses}
\resizebox{\textwidth}{!}{
    % Saw wave
    \begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=1.0cm,y=1.0cm]
    \draw[->,color=black] (0,0) -- (18,0) node [below] {Frequency};;
    \foreach \x in {1,2,...,18}
    \draw[shift={(\x,0)},color=black] (0pt,-2pt);
    \draw[->,color=black] (0,0) -- (0,1) node [below left] {Gain};
    \foreach \y in {1}
    \draw[shift={(0,\y)},color=black] (2pt,0pt) -- (-2pt,0pt);
    \clip(-1,-2) rectangle (18,2);
    \draw[color=blue] (0,1) -- (7,1);
    \draw[color=blue] (7,1) -- (7,0);
    \node [above] at (1,1) {\large Lowpass filter };
    \end{tikzpicture}
}
\resizebox{\textwidth}{!}{
    % Saw wave
    \begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=1.0cm,y=1.0cm]
    \draw[->,color=black] (0,0) -- (18,0) node [below] {Frequency};
    \foreach \x in {1,2,...,18}
    \draw[shift={(\x,0)},color=black] (0pt,-2pt);
    \draw[->,color=black] (0,0) -- (0,1) node [below left] {Gain};
    \foreach \y in {1}
    \draw[shift={(0,\y)},color=black] (2pt,0pt) -- (-2pt,0pt);
    \clip(-1,-2) rectangle (18,2);
    \draw[color=blue] (18,1) -- (11,1);
    \draw[color=blue] (11,1) -- (11,0);
    \node [above] at (1,1) {\large Highpass filter};
    \end{tikzpicture}
}
\resizebox{\textwidth}{!}{
    % Saw wave
    \begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=1.0cm,y=1.0cm]
    \draw[->,color=black] (0,0) -- (18,0) node [below] {Frequency};;
    \foreach \x in {1,2,...,18}
    \draw[shift={(\x,0)},color=black] (0pt,-2pt);
    \draw[->,color=black] (0,0) -- (0,1) node [below left] {Gain};
    \foreach \y in {1}
    \draw[shift={(0,\y)},color=black] (2pt,0pt) -- (-2pt,0pt);
    \clip(-1,-2) rectangle (18,2);
    \draw[color=blue] (6,1) -- (12,1);
    \draw[color=blue] (6,1) -- (6,0);
    \draw[color=blue] (12,1) -- (12,0);
    \node [above] at (1,1) {\large Bandpass filter};
    \end{tikzpicture}
}

\resizebox{\textwidth}{!}{
    % Saw wave
    \begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=1.0cm,y=1.0cm]
    \draw[->,color=black] (0,0) -- (18,0) node [below] {Frequency};;
    \foreach \x in {1,2,...,18}
    \draw[shift={(\x,0)},color=black] (0pt,-2pt);
    \draw[->,color=black] (0,0) -- (0,1) node [below left] {Gain};
    \foreach \y in {1}
    \draw[shift={(0,\y)},color=black] (2pt,0pt) -- (-2pt,0pt);
    \clip(-1,-2) rectangle (18,2);
    \draw[color=blue] (6,1) -- (0,1);
    \draw[color=blue] (12,1) -- (18,1);
    \draw[color=blue] (6,1) -- (6,0);
    \draw[color=blue] (12,1) -- (12,0);
    \node [above] at (1,1) {\large Bandreject filter};
    \end{tikzpicture}
}
\end{figure}

\subsubsection{Implementation of a lowpass and highpass filter with FFT}

The plan is to first convert the time-domain signal into frequency domain, using the Fast Fourier Transform (FFT), multiply it with our filter function, and then convert it back (using the Inverse Fast Fourier Transform, or IFFT). Contrarily to the ideal mathematical idea in the previous section, we have several limitations. For one, we do not have an input of infinite length, the input will come in small blocks at a time. Related is the problem that frequency is tied to the concept of a period. Our signals will only be approximately periodic, but certainly not precisely so.
The result is that whenever we attempt to transform the filtered signal back into time-domain, it becomes a periodic signal, and both extremities change. This causes discontinuities between different frames, which results in audible buzzing. There is a way to avoid this, using the overlap-add method, which depends on buffering a bit of extra data of previous frames and including it in the FFT, causing the IFFT to create a longer wave, which can be cut at the right place with much less of an error.
It makes things worse though, because the FFT/IFFT depends on a signal length of $2^n$ (without either sacrificing a lot performance or using black magic), which means that the real signal length has to be chosen so that added with the overlap constant, it gives a $2^n$ signal. This whole implementation turns out to be rather complex, and quickly became a problem to program. So I searched for simpler methods with less book-keeping involved, and once I had found one I gave up on this particular method.

\subsubsection{Implementation using (2-pole) recursive filters}

One property of conversion between time and frequency domain when considering two functions is what happens to multiplication.
\begin{equation}
j(t) = h(t) \times g(t) \iff J(t) = H(t) * G(t)
\end{equation}
and vis-versa
\begin{equation}
j(t) = h(t) * g(t) \iff J(t) = H(t) \times G(t)
\end{equation}
What this means is that multiplying the frequency spectrums of two waves is identical to convolving their time domain functions.
This means we could also simply pass our filter through an IFFT (the result is called a convolution kernel), and convolve our signal with that.
Convolution works the following way
\begin{equation}
y[n] = h[0]x[n] + h[1]x[n-1] + h[2]x[n-2] + \dots
\end{equation}
{\small \it Note: Convolution also exists for continous functions, but we are dealing with discrete signals so I am switching to that notation.}\\
The problem with convolution is that most interesting filters have very long impulse responses (the time-domain converse of the frequency response), ideal box-filters like we attempted before even possess infinite impulse responses.
We can give up on ideal box-filters, it then becomes a story of trying to get as close as possible while keeping computation low. One method for this are recursive filters; Instead of just using previous input values, we also use previous output values.
\begin{equation}
y[n] = b_0x[n] + b_1x[n-1] + b_2x[n-2] + \dots + a_0y[n] + a_1y[n-1] + a_2y[n-2] + \dots
\end{equation}
While not being of obvious use, this allows us to bypass long convolution kernels. The mathematics for deriving the constants $a_0$,$b_0$,\dots is called the Z-transform and is quite complex. Skipping the details, I chose to copy an analog electronical circuit working with up to two previous values (hence being called a 2-pole filter).
The equation becomes
\begin{equation}
y[n] = b_0x[n] + b_1x[n-1] + b_2x[n-2] + a_0y[n] + a_1y[n-1]
\end{equation}

The frequency response function isn't a perfect box filter anymore, but it is similar enough to work as well, and is much simpler.
It has two parameters, the cutoff frequency (\(f_c\)) as per before, and also a strange parameter commonly called \(Q\) or resonance.
Sampling frequency will be denoted as \(F_s\).
First defining $\omega_0$ which we will need:
\begin{equation}
\omega_0 = \frac{2{\pi}f_c}{F_s}
\end{equation}
The transfer function (equal to the frequency response) of the lowpass filter:
\begin{equation}
H(f) = \frac{\omega_0^2}{f^2 + \frac{\omega_0}{Q}f + \omega_0^2}
\end{equation}
\begin{figure}[h]
\caption{2-pole Lowpass filter frequency response}
\centering
\resizebox{\textwidth}{!}{

\begin{tikzpicture}
\begin{semilogxaxis}[xlabel=Frequency, ylabel=Gain, xmin=1, xmax=20000, ymin=0, ymax=2]

\addplot[domain=1:1e4,color=red] {250000/(x*x + 500*x + 250000)};

\end{semilogxaxis}
\end{tikzpicture}




}
\end{figure}



















The transfer function for the highpass filter:
\begin{equation}
H(f) = \frac{f^2}{f^2 + \frac{\omega_0}{Q}f + \omega_0^2}
\end{equation}




Converting this into coefficients for the recursive equation is a complex procedure, so I will directly jump to the actual values.
First, we create a new constant $a_0$ and negate $a_1$ and $a_2$ to simplify later equations. Our new recursive equation becomes:
\begin{equation}
y[n] = \frac{b_0}{a_0}x[n] + \frac{b_1}{a_0}x[n-1] + \frac{b_2}{a_0}x[n-2] - \frac{a_1}{a_0}y[n-1] - \frac{a_2}{a_0}y[n-2]
\end{equation}
We first calculate $\alpha$:
\begin{equation}
\alpha = \frac{\sin(\omega_0)}{2Q}
\end{equation}
The coefficients for a lowpass filter:
\begin{equation}
b_0 = \frac{1 - \cos(\omega_0}{2}
\end{equation}
\begin{equation}
b_1 = 1 - \cos(\omega_0)
\end{equation}
\begin{equation}
b_2 = \frac{1 - \cos(\omega_0}{2}
\end{equation}
\begin{equation}
a_0 = 1 + \alpha
\end{equation}
\begin{equation}
a_1 = -2\cos(\omega_0)
\end{equation}
\begin{equation}
a_2 = 1 - \alpha
\end{equation}
The coefficients for a highpass filter:
\begin{equation}
b_0 = \frac{1 + \cos(\omega_0)}{2}
\end{equation}
\begin{equation}
b_1 = -1 - \cos(\omega_0))
\end{equation}
\begin{equation}
b_2 = \frac{1 + \cos(\omega_0)}{2}
\end{equation}
\begin{equation}
a_0 = 1 + \alpha
\end{equation}
\begin{equation}
a_1 = -2\cos(\omega_0)
\end{equation}
\begin{equation}
a_2 = 1 - \alpha
\end{equation}

\subsection{Other Primitives}

\subsubsection{Constants}

\subsubsection{Merger and Splitter}

\subsubsection{Adder and Multiplier}

\subsubsection{Range Modifier}

\subsection{GUI}

\clearpage

\section{Results}

\subsection{Capabilities and Limitations of this program}

\section{Looking forward}

\end{document}
